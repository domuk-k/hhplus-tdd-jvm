User Request
|
v
[PointService]
| ↘︎ 비즈니스 정책 검증 (PointPolicy)
|
v
[PointProcessor]  ← per-user Channel / Actor / Mutex
|
v
(정렬된 처리 큐)
|
v
[Repository] ← DB 저장 or Mock 저장
⸻

동시성 제어 전략

선택한 전략: 사용자 단위 ReentrantLock 기반의 애플리케이션 레벨 비관적 락

현재 과제에서는 다음과 같은 제약 조건이 존재한다:
• JPA 사용 불가 (@Version 같은 낙관적 락 적용 불가)
• DB 엔티티 혹은 TableClass 수정 불가 (버전 필드 추가 불가)
• 코틀린 기반 프로젝트
• 동시성 이슈가 발생할 수 있는 포인트 충전/사용 로직이 존재

이러한 제약 조건 하에서는, 일반적인 낙관적 락 방식이나 DB 수준의 락(FOR UPDATE)을 활용하기 어렵기 때문에, 애플리케이션 레벨에서 동시성을 제어하는 방식이 필요하다.

따라서 선택한 방식은 사용자 단위로 ReentrantLock을 매핑한 비관적 락 전략이다. 사용자 ID(userId)를 키로 하여 ConcurrentHashMap<Long, ReentrantLock> 형태로 락을
보관하고, 동시 요청 시 해당 락을 선점한 스레드만 포인트를 수정할 수 있도록 처리한다.

예시는 다음과 같다:

val lockMap = ConcurrentHashMap<Long, ReentrantLock>()

fun charge(userId: Long, amount: Long) {
val lock = lockMap.computeIfAbsent(userId) { ReentrantLock() }
lock.lock()
try {
// 포인트 조회 → 검증 → 충전 → 저장
} finally {
lock.unlock()
}
}

적용 이유
• 사용자 단위로 충전/사용 요청이 발생하므로, userId 단위 직렬화가 효과적이다.
• 충돌 자체를 방지하기 때문에, Race Condition 발생 가능성이 0에 수렴한다.
• JPA나 DB의 도움 없이도 구현 가능하며, 단일 서버 환경에서는 매우 실용적인 해결책이다.
• 테스트 환경에서도 쉽게 재현 가능하고, 문제 발생 시 추적이 쉬운 구조다.

⸻

대안 비교

전략 적용 가능 여부 사유
@Version (낙관적 락)    ❌ 엔티티 수정 불가, JPA 미사용
FOR UPDATE (DB 비관적 락)    ❌ SQL 직접 제어 불가, 과제 구조 제약
AtomicLong, compareAndSet()    ❌ 잔고는 DB 기반이라 메모리 CAS 불가능
ReentrantLock (애플리케이션)    ✅ 단일 서버에서 실현 가능하고 구현 용이

⸻

고려 사항
• 현재 전략은 JVM 단위로만 유효하다.
따라서 멀티 인스턴스(분산 서버) 환경에서는 락이 공유되지 않기 때문에 사용할 수 없다.
• 이 전략은 메모리에 락 객체가 지속적으로 남게 되므로, 필요하다면 LRU 캐시 기반으로 관리하거나 주기적인 정리 로직을 추가할 수 있다.
• 단위 테스트에서는 CompletableFuture나 CountDownLatch를 활용해 충돌 상황을 시뮬레이션하고, 결과의 일관성을 검증한다.

⸻

결론

JPA를 사용할 수 없고, DB 구조를 수정할 수 없는 과제 조건에서는,
ConcurrentHashMap<Long, ReentrantLock>을 활용한 사용자 단위 애플리케이션 락이 가장 현실적이고 안전한 대안이다.
단일 서버 기준으로는 Race Condition을 방지하는 확실한 효과를 제공하며,
명시적이고 이해하기 쉬운 구조이기 때문에 학습적인 목적이나 과제에도 적합한 전략이다.

⸻

필요하면 이 전략 기반으로 실제 동작하는 테스트 코드 예시도 같이 만들어줄 수 있어!

# ✨ 동시성 이슈 해결 전략 정리 (Kotlin + Spring)

> 다음은 다음 조건을 전제로 정리한 동시성 이슈 해결 전략입니다.

- 다일 서버, 다일 DB 기준
- 분산 환경(매니저리 디스크, Redis, Redisson Lock)은 포함하지 않음
- Kotlin Coroutine 기본 사용 사항 추가 정리

---

## 클래스에 따른 동시성 해결 전략

| 전략명                                 | 계층       | 방식  | 롱 유형 | 특징              | 실무 적합도          |
|-------------------------------------|----------|-----|------|-----------------|-----------------|
| `@Version`                          | JPA (DB) | 선언적 | 낭관적  | 충돌 시 예외, 성능 좋음  | 내외 CRUD         |
| `FOR UPDATE`                        | DB       | 명시적 | 비관적  | DB row 롱, 충돌 방지 | 자료, 재고          |
| `ConcurrentHashMap + ReentrantLock` | 애플리케이션   | 명시적 | 비관적  | JVM 내 직렬화       | 다일 서버 환경        |
| `AtomicLong` / `compareAndSet()`    | 애플리케이션   | 명시적 | 낭관적  | 데이터 부딪치기        | 캐시, 건수          |
| `synchronized`                      | 애플리케이션   | 명시적 | 비관적  | 객체 수준 롱         | 간단 동기화          |
| `StampedLock`                       | 애플리케이션   | 명시적 | 혼합형  | 읽기 낭관 + 쓸 비관 분류 | 고성능             |
| 재시도 (loop/이벤트)                      | 서비스      | 보조  | -    | 충돌 발생 시 후보 해결   | `@Version` 과 관련 |

---

## 행위 기본: 상황별 최적 전략

| 상황            | 최적 전략                               |
|---------------|-------------------------------------|
| 충돌 다음, 성능 중요  | `@Version`                          |
| 충돌 빠번, 정확성 중요 | `FOR UPDATE`, `ReentrantLock`       |
| 다일 서버 중차 수행   | `ConcurrentHashMap + ReentrantLock` |
| 건수, 캐시지 칼럼    | `Atomic*`                           |
| 충돌 따라 UX 중요   | `@Version` + 재시도                    |

---

## 코루틴은 동시성 해결 전략인가?

> 아니야! 코루틴(Coroutines)은 동시성 "제어 전략"이 아니라, 동시성 수행 역할하는 기술이야.

### 특징:

- 비돼시적 I/O, 로드 불료를 저거 해주지만
- 데이터 충돌, 정확성 보장은 다른 좌측에 의사

### 자세 사항

| 주의사항                  | 설명                                                          |
|-----------------------|-------------------------------------------------------------|
| 시스템 전체와 데이터 정확성 상관 없음 | 코루틴은 많은 비돼 수행을 수행하지만, 각 작업이 결과에 영향을 미치는 여부는 나누어야 함          |
| 동기적 제어가 필요한 경우        | `Mutex`, `Channel`, `Actor` 같은 동기 메카닉을 이용                   |
| 내부적 시스템 통화 (예: DB)    | 코루틴이 시스템의 터널을 유지하는건 아니기 때문에, 어떤 메소드 내부에서 동기성 진입이 필요한지 확인 필요 |

---

## 후속 계획: 분산 환경 (Redis, Redisson, DB lock table) 변수는 변주 정리 필요!

> 이 문서는 다일 서버 사이드에서 동시성 수행을 보장하기 위한 기본 설계에 초점을 두고 있습니다. 해당 파티 서버가 없을 경우 원지의 필요성을 가지고 있으며, 분산 서버 데이터 모델들은 변주 정리가 따로
> 필요합니다.
